<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Chipmunk Game Dynamics Documentation</title>
		<link rel="stylesheet" type="text/css" href="stylesheet.css" />
	</head>
<body>

<img src="images/logo1_med.png" alt="" /> <a href="http://howlingmoonsoftware.com"><img src="images/hms_logo.png" style="float:right;" alt="" /></a>

<h1>Chipmunk Color Match:</h1>

<img src="images/final.png" />

<p>This tutorial shows you how to create a simple color matching game with Chipmunk Pro and Cocos2D 2.1. It assumes you know the basics about Chipmunk such as how to create spaces, bodies and shapes. You might want to read up on some of the documentation or the Chipmunk Basics tutorial on the <a href="http://chipmunk-physics.net/documentation.php">documentation page</a>.</p>

<p><em>TODO: I either haven't made the Chipmunk Basics tutorial yet or forgot to remove this reminder to myself. Please send me an email if I've forgotten. ;)</em></p>

<p><strong>You can download this tutorial and all the project files from the <a href="https://github.com/slembcke/ChipmunkColorMatch">GitHub page</a>. It also contains alternate projects using UIKit and regular (non-Pro) Chipmunk.</strong></p>

<h2>What Do You Need to Know First?</h2>

<p>This tutorial assumes you have some prior experience with Cocos2D development. It doesn't go into how Cocos2D itself works, although the project is simple enough you can probably figure it out as you go.</p>

<h2>What is Chipmunk?</h2>

<p>Chipmunk is a 2D rigid body physics library distributed under the MIT license. It is intended to be fast, portable, numerically stable, and easy to use. For this reason it's been used in hundreds of games on just about every system you could name. This includes a lot of successful games such as Waking Mars, Night Sky, Zombie Smash, Feed Me Oil and many others. I've put thousands of hours of work over many years to make Chipmunk what it is today. Check out Chipmunk's <a href="http://chipmunk-physics.net">website</a> for more information.</p>

<h2>What is Objective-Chipmunk and Chipmunk Pro?</h2>

<p>Objective-Chipmunk is an Objective-C wrapper for the Chipmunk Physics Library distributed as part of Chipmunk Pro and Chipmunk Indie. While Chipmunk's C API is pretty easy to use, the Objective-C API is even better. The primary advantages of a native Objective-C API include integrating with the Cocoa memory management model (including ARC) and the Chipmunk Object protocol. The Chipmunk Object protocol unifies the basic Chipmunk types as well as making it easy to create custom composite collections of the basic types. Additionally, the wrapper adds many convenience methods for doing common setup tasks as well as helper methods that integrate it with the rest of the Cocoa Touch API. The wrapper tries to do things the Objective-C way, adding useful method variations where it makes sense to do so.</p>

<p>You can find out more information on <a href="http://chipmunk-physics.net">Chipmunk's website</a>. While Objective-Chipmunk is not free like Chipmunk is, the enhanced API will almost certainly save you time and money. You'll also be helping to support further Chipmunk development!</p>

<h1>Overview</h1>

<p>Some of the things you'll see in this tutorial.</p>

<ul>
<li>Setting up a Chipmunk space.
	<ul>
		<li>Create the space and setup some basic properties.</li>
		<li>Add bounds around the space.</li>
		<li>Adding collision handler callbacks to custom process collision events.</li>
	</ul>
</li>
<li>Use the CCPhysicsDebugNode class to draw a space.</li>
<li>Use a fixed timestep for better physics quality.</li>
<li>Setup physics for a simple ball object.</li>
<li>Bind sprites to Chipmunk bodies using the CCPhysicsSprite class.</li>
<li>Implement the ChipmunkObject protocol to make it simple to work with composite physics objects.</li>
</ul>

<h1>Let's get started!</h1>

<p>
This color matching tutorial is inspired by Crayon Ball. In this tutorial game, the goal is to get 4 balls of the same color to touch. Then they are removed. You can interact with the balls in the scene by popping them to make room for more matches. Of course, this is a physics tutorial, so the balls will be rolling over each other in a big pile. The tutorial demonstrates collision handler callbacks, adding and removing physics objects, CCPhysicsSprite, and a lot of Chipmunk basics.  Unlike some of our other tutorials, this one is more of a complete game.
</p>


<p>As I said earlier, it's assumed that you already know how to create a Cocos2D project, and how some of the basic Cocos2D things like scenes and such work. I won't bore you with that by repeating how to do it here. There are many many tutorials on that already. One thing to note is that I'm using ARC in this project. So you might want to read up on how to do that in a Cocos2D project as the templates aren't made for it by default.</p>

<p>One of the new features in Cocos2D 2.1 is the physics integration classes CCPhysicsSprite and CCPhysicsDebugNode. I had originally written these for some Chipmunk example code, but Riq liked them enough that he decided to integrate them into Cocos2D itself. Because the classes rely on external libraries that you may not want in your project, you have to enable it. Look near the top of <code>ccConfig.h</code> and set <code>CC_ENABLE_CHIPMUNK_INTEGRATION</code> to 1.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#683821;">#define CC_ENABLE_CHIPMUNK_INTEGRATION </span><span style="color:#0000ff;">1</span><span style="color:#683821;">
</span></pre>

<p><strong>Important:</strong> As of writing, the current release candidate of Cocos2D 2.1 has an additional define for <code>CC_CHIPMUNK_IMPORT</code> that you should set to <code>"ObjectiveChipmunk.h"</code> if you are using the Objective-Chipmunk wrapper. Previous to this you would need to be careful to import the Objective-Chipmunk.h header into each .m file before anything else to avoid an issue with header conflicts. Going forward it should no longer be an issue though.</p>

<h2>MainLayer.m</h2>
<h3>The [MainLayer init] method:</h3>

<p>Starting in <code>MainLayer.m</code>; let's look at the <code>init</code> method. First it starts out by setting up some Cocos stuff (enabling touch, creating the foreground/background sprites and forcing high quality texture filtering for the balls. I won't paste the code here as it's not related to the physics really.</p>

<p>Next it does the basic setup of the space. The collision slop is the amount of overlap that objects are allowed to have. Increasing it makes it more likely that that they will stay in contact over many frames. That's desirable for this game because if the contacts kept appearing and disappearing it would affect the ability of the game to find groups of colors to match out. It might take a few frames for all of the contacts to be active at the same time. The default value of the collision slop is 0.1, which is reasonable to keep the contact solution stable, but not enough for visible overlap if you are using pixels as your distance units. In general, setting collision slop as high as you can without causing visible overlap will make your simulation run a little more stable.</p>
<p>Next is the basic setup of the space. The collision slop is the amount of overlap that objects are allowed to have. Increasing the slop makes it more likely that that they will stay in contact over many frames. That's desirable for this game because if the contacts kept appearing and disapearing it would affect the ability of the game to find groups of colors to match out. It might take a few frames for all of the contacts to be active at the same time. The default value of the collision slop is 0.1, which is reasonable to keep the contact solution stable, but not enough for visible overlap if you are using pixels as your distance units. In general, setting colision slop as high as you can without causing visible overlap will make your simulation run more stably.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// Set up the physics space
</em></span>    _space = [[ChipmunkSpace <strong><span style="color:#ff0000;">alloc</span></strong>] <span style="color:#6c0540;">init</span>];
    _space.gravity = <span style="color:#003369;">cpv</span>(<span style="color:#0000ff;">0.0f</span>, <span style="color:#0000ff;">-500.0f</span>);
    <span style="color:#236e25;"><em>// Allow collsion shapes to overlap by 2 pixels.
</em></span>    <span style="color:#236e25;"><em>// This will make contacts pop on and off less, which helps it find matching groups better.
</em></span>    _space.collisionSlop = <span style="color:#0000ff;">2.0f</span>;
</pre>

<p>Next up, we add the collision handler callbacks. In Objective-Chipmunk, this takes the form of a target and set of selectors. A collision handler is a set of methods that are called when two shapes that are tagged with specific collision type identifiers collide. This lets you only register for the collisions that you are interested in, like a player touching a monster, instead of having to process every collision that ever occurs.</p>

<p>What we are doing here is iterating the collision types of the balls and registering a callback when two balls of the same color touch. We only want to get callbacks for the preSolve events which are called every frame, so the rest of the selectors are <code>nil</code>. You'll see what the <code>markPair:space:</code> method does later.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// Set up collision handlers for each of the colors.
</em></span>    <strong><span style="color:#881350;">for</span></strong>(cpCollisionType type in [Ball <span style="color:#6c0540;">collisionTypes</span>]){
      <span style="color:#236e25;"><em>// Call the markPair:space: method each time a collision is detected between two balls of the same color.
</em></span>      [_space <span style="color:#6c0540;">addCollisionHandler:</span><strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">typeA:</span>type <span style="color:#6c0540;">typeB:</span>type <span style="color:#6c0540;">begin:</span><strong><span style="color:#881350;">nil</span></strong> <span style="color:#6c0540;">preSolve:</span><strong><span style="color:#881350;">@selector</span></strong>(markPair:space:) <span style="color:#6c0540;">postSolve:</span><strong><span style="color:#881350;">nil</span></strong> <span style="color:#6c0540;">separate:</span><strong><span style="color:#881350;">nil</span></strong>];
    }
</pre>

<p>There is a nice convenience method in Objective-Chipmunk for putting segment shapes around the edges of a box. Remember how the edge shapes have their layers property set to <code>PhysicsEdgeLayers</code>. We'll talk about that more later when processing the touch events.</p>

<pre style="text-align:left;color:#000000; background-color:#; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// Add bounds around the playfield
</em></span>    [_space <span style="color:#6c0540;">addBounds:</span><span style="color:#400080;"><em>CGRectMake</em></span>(<span style="color:#0000ff;">130</span>, <span style="color:#0000ff;">139</span>, <span style="color:#0000ff;">767</span>, <span style="color:#0000ff;">1500</span>) <span style="color:#6c0540;">thickness:</span><span style="color:#0000ff;">20</span> <span style="color:#6c0540;">elasticity:</span><span style="color:#0000ff;">1.0</span> <span style="color:#6c0540;">friction:</span><span style="color:#0000ff;">1.0</span> <span style="color:#6c0540;">layers:</span>PhysicsEdgeLayers <span style="color:#6c0540;">group:</span>CP_NO_GROUP <span style="color:#6c0540;">collisionType:</span><strong><span style="color:#881350;">nil</span></strong>];
</pre>

<p>Cocos2D v2.1 and up now ships with two handy classes that I wrote named <code>CCPhysicsDebugNode</code> and <code>CCPhysicsSprite</code>. CCPhysicsDebugNode is really useful when you are developing your game so you can see that your collision shapes and joints line up with your graphics in the way you expect.</p>

<p>The last thing in the <code>init</code> method is to create the CCPhysicsDebugNode to draw the collision shapes. I made it invisible by default as it gets in the way of the game. There is also some Cocos2D menu code following this to toggle the visibility.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// The debug node will draw an overlay of the physics shapes.
</em></span>    <span style="color:#236e25;"><em>// Very useful for debugging so that you know your collision shapes and graphics line up.
</em></span>    CCPhysicsDebugNode *debugNode = [CCPhysicsDebugNode <span style="color:#6c0540;">debugNodeForChipmunkSpace:</span>_space];
    debugNode.visible = FALSE;
    [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">addChild:</span>debugNode <span style="color:#6c0540;">z:</span>Z_PHYSICS_DEBUG];
</pre>

<h3>The [MainLayer addBall:] and [MainLayer removeBall:] methods:</h3>

<p>The <code>addBall:</code> method is pretty straightforward. It adds the ball to <code>_balls</code> array, adds the ball to the space and adds the sprites for the ball to the scene. Each ball has two sprites. The base sprite, and a second overlay sprite that gives it a shading effect.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;"><em>// Add a Ball object to the scene.
</em></span>-(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">addBall:</span>(Ball *)ball
{
  [_balls <span style="color:#6c0540;">addObject:</span>ball];
  
  <span style="color:#236e25;"><em>// The Ball class implements the ChipmunkObject protocol so you can add it directly to the space.
</em></span>  [_space <span style="color:#6c0540;">add:</span>ball];
  
  <span style="color:#236e25;"><em>// Add each sprite for the ball to the scene.
</em></span>  <strong><span style="color:#881350;">for</span></strong>(CCNode *node in ball.sprites){
    [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">addChild:</span>node];
  }
}
</pre>

<p>The <code>removeBall:</code> method shouldn't have any surprises. Particle effects are good, so I threw in some confetti particles.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;"><em>// This method should look suspiciously similar to addBall:
</em></span>-(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">removeBall:</span>(Ball *)ball
{
  [_space <span style="color:#6c0540;">remove:</span>ball];
  
  <strong><span style="color:#881350;">for</span></strong>(CCNode *node in ball.sprites){
    [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">removeChild:</span>node];
  }
  
  [_balls <span style="color:#6c0540;">removeObject:</span>ball];
  
  <span style="color:#236e25;"><em>// Draw the confetti particles whenever a ball is removed.
</em></span>  CCParticleSystem *particles = [[CCParticleSystemQuad <strong><span style="color:#ff0000;">alloc</span></strong>] <span style="color:#6c0540;">initWithDictionary:</span>PopParticles];
  particles.position = ball.pos;
  particles.autoRemoveOnFinish = TRUE;
  [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">addChild:</span>particles <span style="color:#6c0540;">z:</span>Z_PARTICLES];
}
</pre>

<h3>The [MainLayer update:] method:</h3>

<p>Now let's skip ahead to the <code>update:</code> method. This is the method that Cocos2D calls each time before it draws a frame. The <code>dt</code> variable that it passes is usually going to be about 1/60th of a second, but it's never quite consistent. This is somewhat undesirable for the physics. It's not a good practice to update the physics with these variable sized timesteps because sometimes the CPU might be busy for a few frames. Then the next time you update the physics enough time may have passed so that objects can pass through each other. It also makes the gameplay very non-deterministic and it will act a little differently depending on the framerate.</p>

<p>Instead, you'll want to implement a fixed timestep with Chipmunk. This is really easy to do. I usually do this in <em>all</em> of my games, not just physics ones for the same reasons. Keep the code that updates graphics in <code>update:</code> and create a separate <code>tick:</code> method that handles all the game logic and runs with a fixed timestep. If you want to know more about fixed timesteps, the article in the comment below is a good resource.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;"><em>// This is the update method called by Cocos2D each time it draws a frame.
// It implements a fixed timestep to keep the physics running smoothly and deterministically.
// Using a fixed timestep is *highly* recommended with Chipmunk.
// A good article on fixed timesteps can be found here: </em></span><span style="color:#0000ff;">http://gafferongames.com/game-physics/fix-your-timestep/</span><span style="color:#236e25;"><em>
// I consider extrapolation/interpolation to be fairly optional unless the tickrate is slower than the framerate.
</em></span>-(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">update:</span>(ccTime)dt
{
  ccTime fixed_dt = <span style="color:#0000ff;">1.0</span>/(ccTime)<span style="color:#6c0540;">TICKS_PER_SECOND</span>;
  
  <span style="color:#236e25;"><em>// Add the current dynamic timestep to the accumulator.
</em></span>  <span style="color:#236e25;"><em>// Clamp the timestep though to prevent really long frames from causing a large backlog of fixed timesteps to be run.
</em></span>  _accumulator += <span style="color:#400080;"><em>MIN</em></span>(dt, <span style="color:#0000ff;">0.1</span>);
  <span style="color:#236e25;"><em>// Subtract off fixed-sized chunks of time from the accumulator and step
</em></span>  <strong><span style="color:#881350;">while</span></strong>(_accumulator &gt; fixed_dt){
    [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">tick:</span>fixed_dt];
    _accumulator -= fixed_dt;
  }
}
</pre>
<h3>The [MainLayer tick:] method:</h3>

<p>So then the <code>tick:</code> method is the code that runs with a fixed timestep, independent of the framerate. So far in the game we have an empty playing field without any balls in it. It would be nice if it filled up slowly over time until there were a set number of balls onscreen. An easy way to do that is to check the number of balls and add one every few frames if the number is below that number. Additionally, it tries to insert the ball into the playing field at an empty spot. <code>[ChipmunkSpace shapeTest:]</code> returns true if the shape is overlapping something else in the space given the regular collision filtering rules.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;"><em>// The tick: method is the fixed timestep. See update: for more information.
</em></span>-(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">tick:</span>(ccTime)dt
{
  <span style="color:#236e25;"><em>// Attempt to add a ball every 6 ticks if the playfield has less than 70 balls.
</em></span>  <strong><span style="color:#881350;">if</span></strong>(_ticks%<span style="color:#0000ff;">6</span> == <span style="color:#0000ff;">0</span> &amp;&amp; _balls.count &lt; <span style="color:#0000ff;">70</span>){
    Ball *ball = [Ball <span style="color:#6c0540;">ball</span>];
    
    <span style="color:#236e25;"><em>// Try up to 10 times to find a clear spot to insert the ball.
</em></span>    <strong><span style="color:#881350;">for</span></strong>(<strong><span style="color:#881350;">int</span></strong> i=<span style="color:#0000ff;">0</span>; i&lt;<span style="color:#0000ff;">10</span>; i++){
      <span style="color:#236e25;"><em>// Give the ball a random position.
</em></span>      ball.pos = <span style="color:#003369;">cpv</span>(<span style="color:#0000ff;">512.0f</span> + <span style="color:#0000ff;">300.0f</span>*<span style="color:#003369;">frand_unit</span>(), <span style="color:#0000ff;">1000.0f</span>);
      
      <strong><span style="color:#881350;">if</span></strong>(![_space <span style="color:#6c0540;">shapeTest:</span>ball.shape]){
        <span style="color:#236e25;"><em>// If the area is clear, add the ball and exit the loop.
</em></span>        [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">addBall:</span>ball];
        <strong><span style="color:#881350;">break</span></strong>;
      }
    }
  }
</pre>

<p>While Chipmunk will be passing information on when any two balls of the same color are touching, we still need a way to detect when a group of four balls are touching. To do that, I'll be using the disjoint-set forest algorithm. I won't go into too much detail on how it works in the tutorial, but you can find out more information from the <a href="http://en.wikipedia.org/wiki/Disjoint_set_forest#Disjoint-set_forests">wikipedia page</a>. Before having Chipmunk call <code>markPair:space:</code> to tell us which balls are touching, we need to reset the properties back to their default states. You'll see what there are used for in a couple paragraphs.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// Reset the component properties
</em></span>  <strong><span style="color:#881350;">for</span></strong>(Ball *ball in _balls){
    ball.componentCount = <span style="color:#0000ff;">1</span>;
    ball.componentRoot = ball;
  }
</pre>

<p>Now we can update the space by telling it to step forward in time by the fixed timestep amount. This is also when Chipmunk calls all the collision handler callbacks, one for each pair of shapes that match a collision handler definition. (There is also a default collision handler that you can define if you want to process all the other collisions as well, but this is rarely needed.)</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// Step the space forward in time.
</em></span>  <span style="color:#236e25;"><em>// This is what actually makes the physics go.
</em></span>  [_space <span style="color:#6c0540;">step:</span>dt];
</pre>

<p>During the step, Chipmunk has called the <code>markPair:space</code> method a bunch of times. All the information about what group balls are in, and how many balls in each group will be filled in for us. All we need to do then is to iterate all the balls and check if their group has more than 4 balls in it. If so, remove the ball and make a pop noise for each one. I like to bend the pitch up or down a few notes for variety.</p>

<p>Notice that I'm iterating a copy of the <code>_balls</code> array. There are very few data structures where it's safe to remove objects while iterating. NSMutableArray is no exception. Making a copy of the array to iterate is the simplest solution. People usually get strangely worried about the performance impact of doing this, but it's really a non-issue most of the time. Check the profiler if you don't believe me. ;)</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// At this point Chipmunk called markPair:space: a bunch of times.
</em></span>  <span style="color:#236e25;"><em>// Look for balls in components with 4 or more balls and remove them.
</em></span>  <span style="color:#236e25;"><em>// Not that I'm iterating a copy of the _balls array.
</em></span>  <span style="color:#236e25;"><em>// You can't remove objects from an array while iterating it.
</em></span>  <strong><span style="color:#881350;">for</span></strong>(Ball *ball in [_balls <strong><span style="color:#ff0000;">copy</span></strong>]){
    <span style="color:#236e25;"><em>// Get the component's root and check the count.
</em></span>    Ball *root = ball.componentRoot;
    <strong><span style="color:#881350;">if</span></strong>(root.componentCount &gt;= <span style="color:#0000ff;">4</span>){
      [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">removeBall:</span>ball];
      
      <span style="color:#236e25;"><em>// Play a pop noise.
</em></span>      <strong><span style="color:#881350;">int</span></strong> half_steps = (<span style="color:#003369;">arc4random</span>()%(<span style="color:#0000ff;">2</span>*<span style="color:#0000ff;">4</span> + <span style="color:#0000ff;">1</span>) - <span style="color:#0000ff;">4</span>);
      <strong><span style="color:#881350;">float</span></strong> pitch = <span style="color:#003369;">pow</span>(<span style="color:#0000ff;">2.0f</span>, half_steps/<span style="color:#0000ff;">12.0f</span>);
      [[SimpleAudioEngine <span style="color:#6c0540;">sharedEngine</span>] <span style="color:#6c0540;">playEffect:</span><span style="color:#760f15;">@&quot;ploop.wav&quot;</span> <span style="color:#6c0540;">pitch:</span>pitch <span style="color:#6c0540;">pan:</span><span style="color:#0000ff;">0.0</span> <span style="color:#6c0540;">gain:</span><span style="color:#0000ff;">1.0</span>];
    }
  }
  
  _ticks++;
}
</pre>

<h3>The [MainLayer markPairs:space:] method:</h3>

<p>Now we need to implement the <code>markPairs:space:</code> method that we used with the collision handlers earlier. This is the method that will be doing all the work to figure out how big our groups of colors are.</p>

<p>Chipmunk collision handler methods take a pointer to a cpArbiter C struct and the ChipmunkSpace object that the collision handler was registered with. The cpArbiter pointer is to a C struct instead of an Objective-C object is for a couple reasons. First, Chipmunk's C code manages the memory for cpArbiters, and it's an error to store the pointer anywhere. The other reason is for performance. Chipmunk pools a lot of cpArbiters, discarding and reusing them constantly. Creating an Objective-C object every time to wrap them would be very expensive. Lastly, begin and preSolve collision handler callbacks must return a boolean value. For begin callbacks, returning false means to ignore the collision until separate is called. The preSolve and postSolve callbacks will never be called and there will be no collision response. Returning false from a preSolve callback means to ignore the collision response for the current step only. This gives you a very powerful way to filter collisions dynamically. In this game, we want to return true all the time so the collisions are processed normally.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">-(bool)<span style="color:#6c0540;">markPair:</span>(cpArbiter *)arb <span style="color:#6c0540;">space:</span>(ChipmunkSpace *)space
{
</pre>

<p>Generally the first thing you want to do in a collision handler callback is get the shapes or bodies involved in the collision. Objective-Chipmunk provides two macro functions to help with that. <code>CHIPMUNK_ARBITER_GET_BODIES()</code> and <code>CHIPMUNK_ARBITER_GET_SHAPES()</code>. Both macros take a <code>cpArbiter *</code> and the names of the two variables it should define. The collision types of the colliding shapes will have the same order as when the collision handler was defined. In this case, we are looking for the times when two balls of the same collision type (their color) collide so the order is unimportant.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// Get the two shapes involved in the collision.
</em></span>  <span style="color:#236e25;"><em>// This macro defines the shapeA and shapeB variables for you.
</em></span>  <span style="color:#003369;">CHIPMUNK_ARBITER_GET_BODIES</span>(arb, shapeA, shapeB);
</pre>

<p>If you could only get information on the shapes and bodies that were involved in the collision, you wouldn't be able to do much. For that reason, nearly every Chipmunk object has a data pointer that you can assign to something related to that object, generally the game object that owns it. For example, we set the data pointers on the ball's body and shape to the ball object itself. We need the ball object because we store the grouping information there.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// We set the shapes' data pointers to point to the ball that owns them.
</em></span>  Ball *ballA = shapeA.data;
  Ball *ballB = shapeB.data;
</pre>

<p>To find the groups, I'm using the <a href="http://en.wikipedia.org/wiki/Disjoint_set_forest#Disjoint-set_forests">disjoint-set forest algorithm</a>. The short explanation is that each group of colored balls is identified by a (more or less random) ball in the group. That ball becomes the root and stores the count of the balls in the group. It starts out with each ball being it's own group (and each ball it's own root). Then as <code>markPair:space:</code> is called once for each pair of touching balls, you merge their groups, randomly picking one of the existing roots as the new root. Once all of the touching pairs have been identified, all the balls in the same group will have the same root, and the root will contain the correct count of balls in the group. A very simple algorithm, but a little tricky. Now back in the <code>tick:</code> method it can iterate the balls and remove the ones in groups of more than 4.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// So the rest of the method is half of the implementation of the disjoint set forest algorithm.
</em></span>  <span style="color:#236e25;"><em>// I won't further explain the algorithm here, but it's one of my favorites.
</em></span>  <span style="color:#236e25;"><em>// I use it within Chipmunk itself to find groups of sleeping objects.
</em></span>  <span style="color:#236e25;"><em>// You can find more information here: </em></span><span style="color:#0000ff;">http://en.wikipedia.org/wiki/Disjoint_set_forest#Disjoint-set_forests</span><span style="color:#236e25;"><em>
</em></span>  
  Ball *rootA = ballA.componentRoot;
  Ball *rootB = ballB.componentRoot;
  
  <strong><span style="color:#881350;">if</span></strong>(rootA != rootB){
    <span style="color:#236e25;"><em>// Merge the two component trees.
</em></span>    rootA.componentRoot = rootB.componentRoot;
    rootA.componentCount = rootB.componentCount = rootA.componentCount + rootB.componentCount;
  }
</pre>

<p>The last thing to do is to return a true/false value telling Chipmunk if the collision should be processed normally or discarded. We don't need to do any fancy filtering here. So we just return true.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">  <span style="color:#236e25;"><em>// Returning false would mean Chipmunk should ignore the collision between shapeA and shapeB.
</em></span>  <strong><span style="color:#881350;">return</span></strong> TRUE;
}
</pre>

<h3>The [MainLayer ccTouchesBegan:withEvent:] method:</h3>

<p>The only remaining game logic to implement in the layer is the user input. Cocos2D provides methods for converting input coordinates. Then all you need to do is to use that point to query Chipmunk for the nearest ball shape. Notice how it's using <code>PhysicsBallOnlyBit</code>, as that layer bit will not be set for the border shapes we created in the <code>init</code> method above.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;"><em>// This method removes balls when you touch them.
</em></span>-(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">ccTouchesBegan:</span>(<span style="color:#400080;">NSSet</span> *)touches <span style="color:#6c0540;">withEvent:</span>(<span style="color:#400080;"><em>UIEvent</em></span> *)event
{
  <span style="color:#236e25;"><em>// Convert the touch position to the correct coordinate system.
</em></span>  <span style="color:#400080;"><em>UITouch</em></span> *touch = [touches <span style="color:#6c0540;">anyObject</span>];
  cpVect point = [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">convertTouchToNodeSpace:</span>touch];
  
  <span style="color:#236e25;"><em>// Perform a nearest point query to see what the closest shape to the touch is.
</em></span>  <span style="color:#236e25;"><em>// It only finds shapes that are within fingerRadius distance though.
</em></span>  <span style="color:#236e25;"><em>// Also, it is using PhysicsBallOnlyBit to filter out the results so it will only return a ball and not an edge shape.
</em></span>  cpFloat fingerRadius = <span style="color:#0000ff;">10.0</span>;
  ChipmunkNearestPointQueryInfo *info = [_space <span style="color:#6c0540;">nearestPointQueryNearest:</span>point <span style="color:#6c0540;">maxDistance:</span>fingerRadius <span style="color:#6c0540;">layers:</span>PhysicsBallOnlyBit <span style="color:#6c0540;">group:</span>CP_NO_GROUP];
  <strong><span style="color:#881350;">if</span></strong>(info.shape){
    Ball *ball = info.shape.data;
    [<strong><span style="color:#881350;">self</span></strong> <span style="color:#6c0540;">removeBall:</span>ball];
    
    <strong><span style="color:#881350;">int</span></strong> half_steps = (<span style="color:#003369;">arc4random</span>()%(<span style="color:#0000ff;">2</span>*<span style="color:#0000ff;">4</span> + <span style="color:#0000ff;">1</span>) - <span style="color:#0000ff;">4</span>);
    <strong><span style="color:#881350;">float</span></strong> pitch = <span style="color:#003369;">pow</span>(<span style="color:#0000ff;">2.0f</span>, half_steps/<span style="color:#0000ff;">12.0f</span>);
    [[SimpleAudioEngine <span style="color:#6c0540;">sharedEngine</span>] <span style="color:#6c0540;">playEffect:</span><span style="color:#760f15;">@&quot;pop.wav&quot;</span> <span style="color:#6c0540;">pitch:</span>pitch <span style="color:#6c0540;">pan:</span><span style="color:#0000ff;">0.0</span> <span style="color:#6c0540;">gain:</span><span style="color:#0000ff;">1.0</span>];
  }
}
</pre>

<h2>Ball.m:</h2>
<h3>Collision Types:</h3>

<p>Unlike in regular Chipmunk where collision types are plain integers, collision types are unretained id pointers in Objective-Chipmunk that are compared by value (and not using an equals method). This makes it really easy to use anything you want for an identifier. You can use unique object references such as static NSStrings, class objects, or other object references. Because the pointers are unretained, with a little casting you can also safely store selectors (a convenient way to look up unique identifiers), other pointers or integers.</p>

<p>I often use static NSString objects as identifiers. In this case where we need a unique identifier for each of the 6 colors, NSString references don't necessarily make the most sense, but it's still a useful example I think. We create a static NSArray to hold them, and initialize the array in the <code>initialize</code> class method. I also define a class method to expose the variable to the MainLayer.m file.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><strong><span style="color:#881350;">static</span></strong> <span style="color:#400080;">NSArray</span> *CollisionTypes = <strong><span style="color:#881350;">nil</span></strong>;

+(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">initialize</span>
{
  CollisionTypes = @[<span style="color:#760f15;">@&quot;1&quot;</span>, <span style="color:#760f15;">@&quot;2&quot;</span>, <span style="color:#760f15;">@&quot;3&quot;</span>, <span style="color:#760f15;">@&quot;4&quot;</span>, <span style="color:#760f15;">@&quot;5&quot;</span>, <span style="color:#760f15;">@&quot;6&quot;</span>];
}

+(<span style="color:#400080;">NSArray</span> *)<span style="color:#6c0540;">collisionTypes</span>
{
  <strong><span style="color:#881350;">return</span></strong> CollisionTypes;
}
</pre>

<p>The following property methods complete the disjoint-set forest algorithm from earlier. If you want more information on how it works, see the earlier wikipedia link.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;"><em>// The following two methods implement the other half of the disjoint set forest algorithm.
// See [MainLayer markPairs:space:] for more information.
</em></span>-(Ball *)<span style="color:#6c0540;">componentRoot</span>
{
  <strong><span style="color:#881350;">if</span></strong>(_componentParent != <strong><span style="color:#881350;">self</span></strong>){
    <span style="color:#236e25;"><em>// Path compression.
</em></span>    <span style="color:#236e25;"><em>// Make the next lookup quicker by caching the parent's root.
</em></span>    _componentParent = _componentParent.componentRoot;
  }
  
  <strong><span style="color:#881350;">return</span></strong> _componentParent;
}

-(<strong><span style="color:#881350;">void</span></strong>)<span style="color:#6c0540;">setComponentRoot:</span>(Ball *)componentRoot
{
  <strong><span style="color:#881350;">if</span></strong>(componentRoot == <strong><span style="color:#881350;">self</span></strong>){
    _componentParent = <strong><span style="color:#881350;">self</span></strong>;
  } <strong><span style="color:#881350;">else</span></strong> {
    _componentParent = componentRoot.componentRoot;
  }
}
</pre>

<h3>The init method:</h3>

<p>Finally the last piece: the init method for the ball objects. All that is left is to set up the physics of the individual balls.</p>

<p>The first thing to do is set the random properties of the balls. Give them a random color (out of 6 colors), and give them a random radius. The mass of the ball will vary proportionally with the square of the radius, so we'll just set the mass to that. Because we aren't interacting with any physics objects other than just balls, it doesn't really matter what the mass is as long as it's proportional to the other balls.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <strong><span style="color:#881350;">int</span></strong> color = <span style="color:#003369;">arc4random</span>()%<span style="color:#0000ff;">6</span>;
    
    cpFloat radius = <span style="color:#003369;">cpflerp</span>(<span style="color:#0000ff;">30.0f</span>, <span style="color:#0000ff;">40.0f</span>, <span style="color:#003369;">frand</span>());
    <span style="color:#236e25;"><em>// The mass will increase with the square of the radius.
</em></span>    <span style="color:#236e25;"><em>// Since there are only balls in the game, the actual value don't matter as long as they are relative.
</em></span>    cpFloat mass = radius*radius;
</pre>

<p>To create a body, you need to know its mass (which we already have) and moment of inertia. You can think of the moment inertia as being like the rotational mass of the body. The mass is how hard it is to push a body around, and the moment of inertia (often just called the moment) is how hard it is to make it spin. The moment is affected by the mass of the object, its shape, and how the mass is distributed away from the center. A rookie mistake is to guess the moment of inertia and to just put in a number similar to the mass. Don't do that! You are likely to be wrong by several orders of magnitude and your physics will be very glitchy. Use the <code>cpMomentFor*()</code> functions to help you guess the moment of your objects. For a composite shape, add the value of several moments together.</p>

<p>Once you've created the shape, you can fill in the other properties you want such as the position, velocity, angle, data pointer, etc. The position is set by MainLayer.m, so we'll just leave it out. We set the body's data pointer to self here so we can access the ball that owns the body from Chipmunk callbacks.

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// Create the body.
</em></span>    _body = [ChipmunkBody <span style="color:#6c0540;">bodyWithMass:</span>mass <span style="color:#6c0540;">andMoment:</span><span style="color:#003369;">cpMomentForCircle</span>(mass, <span style="color:#0000ff;">0.0f</span>, radius, cpvzero)];
    <span style="color:#236e25;"><em>// Set the user data pointer of the body to point back at the Ball object.
</em></span>    <span style="color:#236e25;"><em>// That way you can access the Ball object from Chipmunk callbacks and such.
</em></span>    _body.data = <strong><span style="color:#881350;">self</span></strong>;
</pre>

<p>Next, we create a circle shape attached to the body and fill in the properties we want to define. Friction should be pretty self explanatory, and you already know about the data pointer. The layers bitmask value is used to filter only-balls in the nearest point query method earlier. The collision type property is the object reference that we are using when defining collision handlers.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// Create the collision shape of the ball.
</em></span>    _shape = [ChipmunkCircleShape <span style="color:#6c0540;">circleWithBody:</span>_body <span style="color:#6c0540;">radius:</span>radius <span style="color:#6c0540;">offset:</span>cpvzero];
    _shape.friction = <span style="color:#0000ff;">0.7f</span>;
    <span style="color:#236e25;"><em>// The layers is a bitmask used for filtering collisions or queries.
</em></span>    <span style="color:#236e25;"><em>// See the [MainLayer ccTouchesBegan:withEvent:] method for more info.
</em></span>    _shape.layers = PhysicsBallLayers;
    <span style="color:#236e25;"><em>// The collision type is an object reference that is used to figure out which if any collision handler to call.
</em></span>    _shape.collisionType = [CollisionTypes <span style="color:#6c0540;">objectAtIndex:</span>color];
    <span style="color:#236e25;"><em>// Set the user data pointer of the shape to point back at the Ball object.
</em></span>    <span style="color:#236e25;"><em>// That way you can access the Ball object from Chipmunk callbacks and such.
</em></span>    _shape.data = <strong><span style="color:#881350;">self</span></strong>;
</pre>

<p>In order for the Chipmunk objects (bodies, shapes, constraints) to do anything interesting, they generally need to be added to a Chipmunk space. When you add a body to a space, you are asking Chipmunk to update its position. By adding a shape to a space, you are asking Chipmunk to detect and apply collisions with other shapes. Removing the object from the space makes it inactive again. There are also certain things such as static bodies and other so-called, manually updated "rogue" bodies that are not added to the space. Static bodies never move, so you don't want Chipmunk applying gravity to it. For manually updated rogue bodies, you don't want Chipmunk undoing your work. For everything else though, if something isn't added to a space, it's basically inactive.</p>

<p>Objective-Chipmunk has the ChipmunkObject protocol that makes it really easy to add composite physics objects to a space. The ball is a very simple example, containing only a single body and shape, but it becomes very useful for something such as a ragdoll or vehicle composed of many bodies, shapes and constraints. To implement the ChipmunkObject protocol, all you need to do is make a <code>chipmunkObjects</code> method or property that returns an NSArray (or any NSFastEnumeration) of other ChipmunkObjects. This can be any of the basic Chipmunk types such as ChipmunkBody, ChipmunkShape, or ChipmunkConstraint objects, but you can also include your own objects that implement the ChipmunkObject protocol. The latter is very handy when you have complex, hierarchical objects. Since the property is already defined, all we need to do is fill in the instance variable with an NSArray.</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// Set the chipmunkObjects ivar for the property to an NSArray (or any NSFastEnumeration).
</em></span>    <span style="color:#236e25;"><em>// This is what Chipmunk objects to add and remove from the space.
</em></span>    _chipmunkObjects = @[_body, <span style="color:#6c0540;">_shape</span>];
</pre>

<p>Lastly, to finish up the ball objects. We need to give them graphics. The CCPhysicsSprite class makes it really easy to bind a CCSprite and a physics body together. The original class I wrote has been extended to support Box2D bodies as well as Chipmunk and Objective-Chipmunk bodies. All you need to do is to assign a body to the sprite after you create it. The sprite will always have the same position and rotation as the body, and changing the sprite will change the position and rotation of the body its attached to. Handy!</p>

<pre style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">    <span style="color:#236e25;"><em>// The main sprite for the ball.
</em></span>    CCPhysicsSprite *sprite = [CCPhysicsSprite <span style="color:#6c0540;">spriteWithFile:</span>[<span style="color:#400080;">NSString</span> <span style="color:#6c0540;">stringWithFormat:</span><span style="color:#760f15;">@&quot;ball_%d.png&quot;</span>, <span style="color:#6c0540;">color</span>]];
    sprite.chipmunkBody = _body;
    sprite.scale = <span style="color:#0000ff;">2.0f</span>*radius/(sprite.contentSize.width - <span style="color:#0000ff;">8.0f</span>);
    sprite.zOrder = Z_BALLS;
    
    <span style="color:#236e25;"><em>// The highlight sprite overlain over the regular sprite.
</em></span>    <span style="color:#236e25;"><em>// It's set to ignore the rotation of the body.
</em></span>    CCPhysicsSprite *highlight = [CCPhysicsSprite <span style="color:#6c0540;">spriteWithFile:</span><span style="color:#760f15;">@&quot;ball_highlight.png&quot;</span>];
    highlight.chipmunkBody = _body;
    highlight.ignoreBodyRotation = TRUE;
    highlight.scale = sprite.scale;
    highlight.zOrder = Z_BALL_HIGHLIGHTS;
    
    _sprites = @[sprite, <span style="color:#6c0540;">highlight</span>];
  }
  
  <strong><span style="color:#881350;">return</span></strong> <strong><span style="color:#881350;">self</span></strong>;
}
</pre>

<p>With that, the ball class is complete. It doesn't actually need any more methods. All of the physics and rendering and handled by Chipmunk and Cocos2D. So there isn't much the Ball class needs to do other than to set up the objects for them.</p>

<h1>Conclusion</h1>

<p>That basically wraps up the code for the project. At this point you know everything you need to make a color matching game with Chipmunk Pro and Cocos2D. Again, if you want to grab the code for the project, you can get it from the <a href="https://github.com/slembcke/ChipmunkColorMatch">GitHub page</a>.</p>

<div class="Copyright">Copyright 2012 by Scott Lembcke and Howling Moon Software.</div>

	</body>
</html>
